<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Gerard Braad's blog</title><link href="http://gbraad.nl/blog/" rel="alternate"></link><link href="http://gbraad.nl/blog/feeds/devops.atom.xml" rel="self"></link><id>http://gbraad.nl/blog/</id><updated>2016-10-03T00:00:00+08:00</updated><entry><title>Replace scripts with Ansible: package installation</title><link href="http://gbraad.nl/blog/replace-scripts-with-ansible-package-installation.html" rel="alternate"></link><published>2016-10-03T00:00:00+08:00</published><author><name>Gerard Braad &lt;me@gbraad.nl&gt;</name></author><id>tag:gbraad.nl,2016-10-03:blog/replace-scripts-with-ansible-package-installation.html</id><summary type="html">&lt;p&gt;Installing and configuring software on one machine, for instance your own
developer's environment, is an 'easy' task. But how about your team? Or
production? Everything is documented and you only probably install some of the
components manually, or better, you automate this using a set of shell scripts.
The environment is now reproducible. Everything is fine.&lt;/p&gt;
&lt;p&gt;Running a set of scripts is not a bad idea, but often what lacks is the
maintenance on them or just the magic contained in them. I do not
have to make the case for general configuration management,
'configuration as code' or even #DevOps I hope? In this article I will show why
I use Ansible for almost all my scripts. Even small one of.&lt;/p&gt;
&lt;h2&gt;Environment&lt;/h2&gt;
&lt;p&gt;Although I have a preference for the operating system and distribution I use, I
have to deal with many different versions and variants. On my workstation I
prefer to use Fedora, but at work we deploy on CentOS. Some of my colleagues
tend to prefer Ubuntu (latest), and customers are stuck on LTS releases. A very
common situation. In one week, I had to deal with: Alpine, CentOS, Fedora,
Ubuntu, (Open)SUSE, Debian, Windows, etc. This is of course an extreme case.&lt;/p&gt;
&lt;p&gt;You would prefer to use a single environment for both development and
production. When the production environment is fixed, the solution is easier.
You will likely use a tool like Vagrant to stand up an environment, or some
other virtualization soltuion. But what if you develop for an environment where
both Ubuntu and CentOS are an option? In my case this happens a lot because of
work for OpenStack, or just general Linux tool development.&lt;/p&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;Below I will discuss a small example of dealing with package installation. Let's
consider you have to use Ubuntu and Fedora. This means that you already have to
deal with two different package managers, oh wait, three; &lt;code&gt;apt&lt;/code&gt; on Ubuntu and
&lt;code&gt;yum&lt;/code&gt; or &lt;code&gt;dnf&lt;/code&gt; on Fedora.&lt;/p&gt;
&lt;h3&gt;Bash script&lt;/h3&gt;
&lt;p&gt;As a crude solution, you could do the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;
&lt;span class="nv"&gt;APTPKGS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;git tmux zsh mc stow python-psutil&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;RPMPKGS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;git tmux zsh mc stow python-psutil&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;# Crude multi-os installation option&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -x &lt;span class="s2"&gt;&amp;quot;/usr/bin/apt-get&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
   sudo apt-get install -y &lt;span class="nv"&gt;$APTPKGS&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -x &lt;span class="s2"&gt;&amp;quot;/usr/bin/dnf&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
   sudo dnf install -y &lt;span class="nv"&gt;$RPMPKGS&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -x &lt;span class="s2"&gt;&amp;quot;/usr/bin/yum&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
   sudo yum install -y &lt;span class="nv"&gt;$RPMPKGS&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This basically checks if a certain executable is available, and will use that
with a defined list of packages to install. If both &lt;code&gt;yum&lt;/code&gt; and &lt;code&gt;dnf&lt;/code&gt; is
installed, it will in this case use &lt;code&gt;dnf&lt;/code&gt; as it resolves first. This is likely
what you want, but it is hidden logic. But what if you have installed &lt;code&gt;yum&lt;/code&gt; on
Ubuntu? Also, because of this case, &lt;code&gt;apt-get&lt;/code&gt; will resolve first. But again,
this is undocumented in this script. But this knowledge should not be needed.&lt;/p&gt;
&lt;p&gt;Note: in this case, the packages are the same for both platforms, but this is
not a guarantee. Therefore I use a variable for this.&lt;/p&gt;
&lt;h3&gt;Ansible playbook&lt;/h3&gt;
&lt;p&gt;Ansible solves this problem by offering a general &lt;code&gt;package&lt;/code&gt; module. You can use
&lt;code&gt;yum&lt;/code&gt; and &lt;code&gt;apt&lt;/code&gt; specific options, but I prefer to use &lt;code&gt;package&lt;/code&gt; instead. Below 
is a playbook that has the same behaviour as the above mentioned script:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="l l-Scalar l-Scalar-Plain"&gt;tasks&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;name&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;Install list of required packages&lt;/span&gt;
    &lt;span class="l l-Scalar l-Scalar-Plain"&gt;package&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;name={{ item }} state=installed&lt;/span&gt;
    &lt;span class="l l-Scalar l-Scalar-Plain"&gt;become&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;yes&lt;/span&gt;
    &lt;span class="l l-Scalar l-Scalar-Plain"&gt;become_method&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo&lt;/span&gt;
    &lt;span class="l l-Scalar l-Scalar-Plain"&gt;with_items&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;tmux&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;zsh&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;stow&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;python-psutil&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;mc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Because of the task name, it becomes clear what the intention is of the commands
that follow. In this case, this will use the package manager based on the OS
Family that Ansible will find. This means we do not need to have the knowledge
of what to pick first. There is however a problem. What if the packages have
different names?&lt;/p&gt;
&lt;h3&gt;Conditionals&lt;/h3&gt;
&lt;p&gt;For this Ansible offers conditionals which you can use with &lt;code&gt;when&lt;/code&gt;. Below is
an example that will install the development tools on Ubuntu or Fedora, based
on the &lt;code&gt;ansible_distribution&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#!/usr/bin/env ansible-playbook&lt;/span&gt;
&lt;span class="nn"&gt;---&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;hosts&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;localhost&lt;/span&gt;
  &lt;span class="c1"&gt;#remote_user: root&lt;/span&gt;
  &lt;span class="l l-Scalar l-Scalar-Plain"&gt;become_method&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;sudo&lt;/span&gt;

  &lt;span class="l l-Scalar l-Scalar-Plain"&gt;tasks&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;name&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;Install Git&lt;/span&gt;
    &lt;span class="l l-Scalar l-Scalar-Plain"&gt;package&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;name=git state=installed&lt;/span&gt;
    &lt;span class="l l-Scalar l-Scalar-Plain"&gt;become&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;yes&lt;/span&gt;

  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;name&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;install the &amp;#39;Development tools&amp;#39; package group&lt;/span&gt;
    &lt;span class="l l-Scalar l-Scalar-Plain"&gt;package&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;name=&amp;quot;@Development tools&amp;quot; state=present&lt;/span&gt;
    &lt;span class="l l-Scalar l-Scalar-Plain"&gt;when&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;  &lt;span class="l l-Scalar l-Scalar-Plain"&gt;ansible_distribution == &amp;#39;CentOS&amp;#39; or&lt;/span&gt;
           &lt;span class="l l-Scalar l-Scalar-Plain"&gt;ansible_distribution == &amp;#39;Red Hat Enterprise Linux&amp;#39; or&lt;/span&gt;
           &lt;span class="l l-Scalar l-Scalar-Plain"&gt;ansible_distribution == &amp;#39;Fedora&amp;#39;&lt;/span&gt;
    &lt;span class="l l-Scalar l-Scalar-Plain"&gt;become&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;yes&lt;/span&gt;

  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;name&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;Install the &amp;#39;build-essential&amp;#39; meta package&lt;/span&gt;
    &lt;span class="l l-Scalar l-Scalar-Plain"&gt;package&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;name=&amp;quot;build-essential&amp;quot; state=present&lt;/span&gt;
    &lt;span class="l l-Scalar l-Scalar-Plain"&gt;when&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;ansible_distribution == &amp;#39;Debian&amp;#39; or&lt;/span&gt;
          &lt;span class="l l-Scalar l-Scalar-Plain"&gt;ansible_distribution == &amp;#39;Ubuntu&amp;#39;&lt;/span&gt;
    &lt;span class="l l-Scalar l-Scalar-Plain"&gt;become&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;yes&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can also use &lt;code&gt;ansible_os_family == "RedHat"&lt;/code&gt; to be less specific about the
distribution you are on.&lt;/p&gt;
&lt;h3&gt;Include&lt;/h3&gt;
&lt;p&gt;You can combine conditionals with almost anything in Ansible, for instance to
include or not another playbook. Below is a simple solution of this when you
want to split the install instructions into separate files.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- include: install-centos.yml
  when: ansible_distribution == &amp;quot;CentOS&amp;quot;

- include: install-ubuntu.yml
  when: ansible_distribution == &amp;quot;Ubuntu&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;With Ansible it is possible to create complex instructions that can be more
maintainable than when using just scripts. Of course, just using Ansible will
not act as a silver bullet. But because a playbook is more readable, the process
of refactoring is easier.&lt;/p&gt;
&lt;p&gt;In future articles I will talk about other aspects where the move to Ansible
helped me. However, the bootstrap process remains... I wish there was a way to
&lt;a href="https://github.com/gbraad/automate-everything"&gt;Automate everything&lt;/a&gt; ;-)&lt;/p&gt;
&lt;p&gt;Hope this article has been helpful to you. If so, please consider tweeting about
it. Or leave a comment if you have suggestions...&lt;/p&gt;</summary><category term="deployment"></category><category term="configuration"></category><category term="ansible"></category><category term="devops"></category></entry></feed>